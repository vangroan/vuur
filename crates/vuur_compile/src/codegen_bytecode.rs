use vuur_parse::expr::{Expr, OperatorKind};
use vuur_parse::module::VuurModule;
use vuur_parse::stmt::{DefStmt, SimpleStmt};

use crate::bytecode::opcodes::{self, OpCode};
use crate::chunk::{Chunk, ChunkHeader};
use crate::codegen::Codegen;
use crate::constants::*;
use crate::error::{CompileError, ErrorKind, Result};
use crate::limits::*;

// TODO: Replace String error with proper error type

/// Executable block
struct FuncState {
    /// Name of the callable.
    ///
    /// For functions this is the function name, for the
    /// top level anonymous module function this would be `None`.
    name: Option<String>,
    /// Unnamed scalar constant values.
    constants: ConstantTable,
    /// String constant values.
    strings: Vec<String>,
    /// Local variable values, including the function's parameters.
    locals: Vec<String>,
    bytecode: Vec<u32>,
}

impl FuncState {
    fn add_constant(&mut self, konst: ConstValue) -> usize {
        self.constants.add_constant(konst)
    }

    fn emit_simple(&mut self, op: OpCode) {
        self.bytecode.push(op as u32);
    }

    fn emit_k(&mut self, op: OpCode, k: u32) {
        debug_assert!(k <= 0xFFFFFF, "instruction format only supports 24-bit argument");
        let prefix = op as u32;
        let data = (k as u32 & 0xFFFFFF) << 8;
        self.bytecode.push(prefix | data);
    }

    fn emit_a(&mut self, op: OpCode, a: i32) {
        debug_assert!(
            a <= INSTRUCTION_A_MAX,
            "instruction format only supports 24-bit argument"
        );
        let prefix = op as u32;
        let data = (a as u32 & 0xFFFFFF) << 8;
        self.bytecode.push(prefix | data);
    }
}

impl Default for FuncState {
    fn default() -> Self {
        Self {
            name: None,
            constants: ConstantTable::new(),
            strings: Vec::new(),
            locals: Vec::new(),
            bytecode: Vec::new(),
        }
    }
}

struct ConstantTable {
    values: Vec<ConstValue>,
    next_index: usize,
}

impl ConstantTable {
    fn new() -> Self {
        Self {
            values: vec![],
            next_index: 0,
        }
    }

    fn add_constant(&mut self, value: ConstValue) -> usize {
        match self.values.iter().position(|el| el == &value) {
            Some(index) => index,
            None => {
                let next_index = self.next_index;
                self.next_index += value.encoded_size();
                self.values.push(value);
                next_index
            }
        }
    }

    fn len(&self) -> usize {
        self.next_index
    }

    fn is_empty(&self) -> bool {
        self.next_index == 0
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
enum ConstValue {
    I32(i32),
    F32(f32),
    I64(i64),
    F64(f64),
    Bool(bool),
}

impl ConstValue {
    /// Size of constant value when encoded into u32.
    fn encoded_size(&self) -> usize {
        match self {
            Self::I32(_) | Self::F32(_) => 1,
            Self::I64(_) | Self::F64(_) => 2,
            Self::Bool(_) => 1,
        }
    }

    fn to_bits(&self) -> u32 {
        match *self {
            Self::I32(val) => val as u32,
            Self::F32(val) => val.to_bits(),
            _ => 0,
        }
    }

    fn to_bits2(&self) -> [u32; 2] {
        match *self {
            _ => todo!(),
        }
    }
}

#[deprecated]
#[doc(hidden)]
pub fn write_header(chunk: &mut Chunk) {
    // chunk.code.push(CHUNK_START_BYTE);
    // chunk.code.extend_from_slice(CHUNK_HEADER);
    // chunk.code.push(CHUNK_VERSION);
    // chunk.code.push(CHUNK_ENDIAN_LIT);
    // chunk.code.push(CHUNK_SIZE_32);

    // // File format reserves bytes for future use.
    // for _ in chunk.code.len()..CHUNK_HEADER_RESERVED {
    //     chunk.code.push(0);
    // }
}

/// Code generator that outputs interpreter bytecode.
pub struct BytecodeCodegen {
    /// Result buffer of generated bytecode
    chunk: Chunk,
    /// Call stack info.
    funcs: Vec<FuncState>,
    /// Mapping of bytecode to original source line.
    ///
    /// The index in the vector is equal to the bytecode's offset
    /// in the generated binary. The elements are line numbers in
    /// the source code text, starting at 1.
    ///
    /// Used to add source text information when disassembling.
    // TODO: Source mapping
    _lines: Vec<usize>,
}

impl BytecodeCodegen {
    pub fn new() -> Self {
        Self {
            chunk: Chunk::default(),
            funcs: Vec::with_capacity(64),
            _lines: Vec::new(),
        }
    }

    fn take(&mut self) -> Chunk {
        let mut chunk = Chunk::default();
        std::mem::swap(&mut chunk, &mut self.chunk);

        self.reset();

        chunk
    }

    /// Reset internal state of code generator to a clean slate,
    /// ready for another code generation run.
    fn reset(&mut self) {
        *self = BytecodeCodegen::new();
    }

    /// Byte offset of next instruction.
    fn next_offset(&self) -> usize {
        self.chunk.code.len()
    }

    fn top_frame_mut(&mut self) -> &mut FuncState {
        // Create default function to make this infallible.
        if self.funcs.is_empty() {
            self.funcs.push(FuncState::default());
            &mut self.funcs[0]
        } else {
            self.funcs.last_mut().unwrap()
        }
    }

    fn write_header(&mut self) {
        // self.chunk.code.push(CHUNK_START_BYTE);
        // self.chunk.code.extend_from_slice(CHUNK_HEADER);
        // self.chunk.code.push(CHUNK_VERSION);

        // // File format reserves bytes for future use.
        // for _ in self.chunk.code.len()..CHUNK_HEADER_RESERVED {
        //     self.chunk.code.push(0);
        // }
        let header = ChunkHeader {
            version: CHUNK_VERSION,
            endianess: CHUNK_ENDIAN_LIT,
            size_t: CHUNK_SIZE_32,
        };
        self.chunk.header = header;
    }

    /// Pops the top function state and emits it into the chunk bytecode.
    fn finish_func(&mut self) -> Result<()> {
        match self.funcs.pop() {
            Some(func) => {
                // Emit function def header
                self.chunk.emit_simple(opcodes::FUNC);

                // Write constants
                self.chunk.emit_data(func.constants.len() as u32);
                for konst in &func.constants.values {
                    self.chunk.emit_data(konst.to_bits());
                }

                // Write bytecode instructions
                self.chunk.code.extend_from_slice(&func.bytecode);

                Ok(())
            }
            None => Err(CompileError::new(
                ErrorKind::Compiler,
                "failed to finalize function: no current function being compiled",
            )),
        }
    }

    fn compile_module(&mut self, module: &VuurModule) -> Result<()> {
        self.write_header();

        // Top level of a module is an anonymous function
        self.funcs.push(FuncState { ..FuncState::default() });

        self.compile_stmts(&module.stmts)?;
        self.compile_return();

        self.finish_func();

        Ok(())
    }

    fn compile_stmts(&mut self, stmts: &[DefStmt]) -> Result<()> {
        for def_stmt in stmts {
            match def_stmt {
                DefStmt::Simple(stmt) => {
                    // FIXME: Remove comment when `force_multiline_blocks` is stabilised: https://github.com/rust-lang/rustfmt/issues/3374
                    match stmt {
                        SimpleStmt::Expr(expr) => self.compile_expr(expr)?,
                        _ => todo!(),
                    }
                }
                _ => todo!(),
            }
        }

        Ok(())
    }

    fn compile_expr(&mut self, expr: &Expr) -> Result<()> {
        match expr {
            // Number literal becomes a constant with no name.
            Expr::Num(num) => {
                let scope = self.top_frame_mut();
                let lit = num.value;

                // If the literal is small enough, inline it into an immediate instruction.
                if lit >= 0 && lit <= INSTRUCTION_A_MAX {
                    scope.emit_a(opcodes::PUSH_CONST_IMM, lit);
                } else {
                    // Integer is too large to be inlined into the bytecode.
                    // Add it to the constant table.
                    // TODO: Floats
                    let index = scope.add_constant(ConstValue::I32(lit));

                    if index > MAX_CONSTANTS {
                        return Err(CompileError::new(
                            ErrorKind::Compiler,
                            "maximum function constants exceeded",
                        ));
                    }

                    // Emit
                    scope.emit_k(opcodes::PUSH_CONST, index as u32);
                }
            }
            Expr::Binary(binary) => {
                self.compile_expr(&binary.lhs)?;
                self.compile_expr(&binary.rhs)?;

                let scope = self.top_frame_mut();

                match binary.operator.kind {
                    OperatorKind::Add => {
                        scope.emit_simple(opcodes::ADD_I32);
                        // self.chunk.emit_simple(Instruction::Add_I32);
                    }
                    OperatorKind::Sub => {
                        scope.emit_simple(opcodes::SUB_I32);
                    }
                    OperatorKind::Mul => {
                        scope.emit_simple(opcodes::MUL_I32);
                        // self.chunk.emit_simple(Instruction::Mul_I32);
                    }
                    _ => todo!("operator kind {:?} not implemented yet", binary.operator.kind),
                }
            }
            Expr::Group(group) => {
                self.compile_expr(&group.expr)?;
            }
            Expr::NameAccess(_) => {
                eprint!("name access not implemented");
                self.top_frame_mut().emit_simple(opcodes::NOOP);
            }
            _ => todo!(),
        }

        Ok(())
    }

    fn compile_return(&mut self) {
        self.top_frame_mut().emit_simple(opcodes::RETURN)
    }
}

impl Codegen for BytecodeCodegen {
    type Input = VuurModule;
    type Output = Chunk;

    fn compile(&mut self, module: &Self::Input) -> Result<Self::Output> {
        self.compile_module(module)?;

        Ok(self.take())
    }
}

macro_rules! encode {
    ($op:expr, $a:expr, $b:expr, $c:expr) => {
        op << 24 & a << 16 & b << 8 & c
    };
}

pub trait BytecodeChunkExt {
    fn emit_simple(&mut self, op: OpCode);
    fn emit_a(&mut self, op: OpCode, a: i32);
    fn emit_data(&mut self, data: u32);
}

impl BytecodeChunkExt for Chunk {
    fn emit_simple(&mut self, op: OpCode) {
        self.code.push(op as u32);
    }

    fn emit_a(&mut self, op: OpCode, a: i32) {
        debug_assert!(a <= 0xFFFFFF, "instruction format only supports 12-bit argument");
        let prefix = op as u32;
        let data = (a as u32 & 0xFFFFFF) << 8;
        self.code.push(prefix | data);
    }

    fn emit_data(&mut self, data: u32) {
        self.code.push(data);
    }
}
