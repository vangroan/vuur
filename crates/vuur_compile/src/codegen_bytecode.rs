use vuur_parse::expr::{Expr, OperatorKind};
use vuur_parse::module::VuurModule;
use vuur_parse::stmt::{DefStmt, SimpleStmt};

use crate::bytecode::{encode_u64, opcodes, OpCode, WriteBytecode};
use crate::chunk::{Chunk, ChunkHeader};
use crate::codegen::Codegen;
use crate::constants::*;
use crate::error::{CompileError, ErrorKind, Result};
use crate::limits::*;

// TODO: Replace String error with proper error type

/// Executable block
struct FuncState {
    /// Name of the callable.
    ///
    /// For functions this is the function name, for the
    /// top level anonymous module function this would be `None`.
    name: Option<String>,
    /// Unnamed scalar constant values.
    constants: ConstantTable,
    /// String constant values.
    strings: Vec<String>,
    /// Local variable values, including the function's parameters.
    locals: Vec<String>,
    bytecode: Vec<u32>,
}

impl FuncState {
    fn add_constant(&mut self, konst: ConstValue) -> usize {
        self.constants.add_constant(konst)
    }
}

impl Default for FuncState {
    fn default() -> Self {
        Self {
            name: None,
            constants: ConstantTable::new(),
            strings: Vec::new(),
            locals: Vec::new(),
            bytecode: Vec::new(),
        }
    }
}

struct ConstantTable {
    values: Vec<ConstValue>,
    next_index: usize,
}

impl ConstantTable {
    fn new() -> Self {
        Self {
            values: vec![],
            next_index: 0,
        }
    }

    fn add_constant(&mut self, value: ConstValue) -> usize {
        match self.values.iter().position(|el| el == &value) {
            Some(index) => index,
            None => {
                let next_index = self.next_index;
                self.next_index += value.encoded_size();
                self.values.push(value);
                next_index
            }
        }
    }

    fn len(&self) -> usize {
        self.next_index
    }

    fn is_empty(&self) -> bool {
        self.next_index == 0
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
enum ConstValue {
    I32(i32),
    F32(f32),
    I64(i64),
    F64(f64),
    Bool(bool),
}

impl ConstValue {
    /// Size of constant value when encoded into u32.
    fn encoded_size(&self) -> usize {
        match self {
            Self::I32(_) | Self::F32(_) => 1,
            Self::I64(_) | Self::F64(_) => 2,
            Self::Bool(_) => 1,
        }
    }

    fn to_bits(&self) -> Option<u32> {
        match *self {
            Self::I32(val) => Some(val as u32),
            Self::F32(val) => Some(val.to_bits()),
            _ => None,
        }
    }

    fn to_bits2(&self) -> Option<[u32; 2]> {
        match *self {
            Self::I64(val) => Some(encode_u64(val as u64)),
            Self::F64(val) => Some(encode_u64(val.to_bits())),
            _ => None,
        }
    }
}

/// Code generator that outputs interpreter bytecode.
pub struct BytecodeCodegen {
    /// Result buffer of generated bytecode
    chunk: Chunk,
    /// Call stack info.
    funcs: Vec<FuncState>,
    /// Mapping of bytecode to original source line.
    ///
    /// The index in the vector is equal to the bytecode's offset
    /// in the generated binary. The elements are line numbers in
    /// the source code text, starting at 1.
    ///
    /// Used to add source text information when disassembling.
    // TODO: Source mapping
    _lines: Vec<usize>,
}

impl BytecodeCodegen {
    pub fn new() -> Self {
        Self {
            chunk: Chunk::default(),
            funcs: Vec::with_capacity(64),
            _lines: Vec::new(),
        }
    }

    fn take(&mut self) -> Chunk {
        let mut chunk = Chunk::default();
        std::mem::swap(&mut chunk, &mut self.chunk);

        self.reset();

        chunk
    }

    /// Reset internal state of code generator to a clean slate,
    /// ready for another code generation run.
    fn reset(&mut self) {
        *self = BytecodeCodegen::new();
    }

    fn top_frame_mut(&mut self) -> &mut FuncState {
        // Create default function to make this infallible.
        if self.funcs.is_empty() {
            self.funcs.push(FuncState::default());
            &mut self.funcs[0]
        } else {
            self.funcs.last_mut().unwrap()
        }
    }

    fn write_header(&mut self) {
        let header = ChunkHeader {
            version: CHUNK_VERSION,
            endianess: CHUNK_ENDIAN_LIT,
            size_t: CHUNK_SIZE_32,
        };
        self.chunk.header = header;
    }

    /// Pops the top function state and emits it into the chunk bytecode.
    fn finish_func(&mut self) -> Result<()> {
        match self.funcs.pop() {
            Some(func) => {
                // Emit function def header
                self.chunk.code_mut().write_simple(opcodes::FUNC)?;

                // Write constants
                self.chunk.code_mut().write_data(func.constants.len() as u32)?;
                for konst in &func.constants.values {
                    self.chunk.code_mut().write_data(konst.to_bits().unwrap_or_default())?;
                }

                // Write bytecode instructions
                self.chunk.code.extend_from_slice(&func.bytecode);

                Ok(())
            }
            None => Err(CompileError::new(
                ErrorKind::Compiler,
                "failed to finalize function: no current function being compiled",
            )),
        }
    }

    fn compile_module(&mut self, module: &VuurModule) -> Result<()> {
        self.write_header();

        // Top level of a module is an anonymous function
        self.funcs.push(FuncState { ..FuncState::default() });

        self.compile_stmts(&module.stmts)?;
        self.compile_return()?;

        self.finish_func()?;

        Ok(())
    }

    fn compile_stmts(&mut self, stmts: &[DefStmt]) -> Result<()> {
        for def_stmt in stmts {
            match def_stmt {
                DefStmt::Simple(stmt) => {
                    // FIXME: Remove comment when `force_multiline_blocks` is stabilised: https://github.com/rust-lang/rustfmt/issues/3374
                    match stmt {
                        SimpleStmt::Expr(expr) => self.compile_expr(expr)?,
                        _ => todo!(),
                    }
                }
                _ => todo!(),
            }
        }

        Ok(())
    }

    fn compile_expr(&mut self, expr: &Expr) -> Result<()> {
        match expr {
            // Number literal becomes a constant with no name.
            Expr::Num(num) => {
                let scope = self.top_frame_mut();
                let lit = num.value;

                // If the literal is small enough, inline it into an immediate instruction.
                if lit >= 0 && lit <= INSTRUCTION_A_MAX {
                    scope.bytecode.write_a(opcodes::PUSH_CONST_IMM, lit)?;
                } else {
                    // Integer is too large to be inlined into the bytecode.
                    // Add it to the constant table.
                    // TODO: Floats
                    let index = scope.add_constant(ConstValue::I32(lit));

                    if index > MAX_CONSTANTS {
                        return Err(CompileError::new(
                            ErrorKind::Compiler,
                            "maximum function constants exceeded",
                        ));
                    }

                    // Emit
                    scope.bytecode.write_k(opcodes::PUSH_CONST, index as u32)?;
                }
            }
            Expr::Unary(unary) => {
                self.compile_expr(&unary.rhs)?;

                let scope = self.top_frame_mut();

                match unary.operator.kind {
                    OperatorKind::Neg => {
                        scope.bytecode.write_simple(opcodes::NEG_I32)?;
                    }
                    _ => todo!("unary operator kind {:?}", unary.operator.kind),
                }
            }
            Expr::Binary(binary) => {
                self.compile_expr(&binary.lhs)?;
                self.compile_expr(&binary.rhs)?;

                let scope = self.top_frame_mut();

                match binary.operator.kind {
                    OperatorKind::Add => {
                        scope.bytecode.write_simple(opcodes::ADD_I32)?;
                        // self.chunk.emit_simple(Instruction::Add_I32);
                    }
                    OperatorKind::Sub => {
                        scope.bytecode.write_simple(opcodes::SUB_I32)?;
                    }
                    OperatorKind::Mul => {
                        scope.bytecode.write_simple(opcodes::MUL_I32)?;
                        // self.chunk.emit_simple(Instruction::Mul_I32);
                    }
                    _ => todo!("binary operator kind {:?}", binary.operator.kind),
                }
            }
            Expr::Group(group) => {
                self.compile_expr(&group.expr)?;
            }
            Expr::NameAccess(_) => {
                eprint!("name access not implemented");
                self.top_frame_mut().bytecode.write_simple(opcodes::NOOP)?;
            }
            _ => todo!(),
        }

        Ok(())
    }

    fn compile_return(&mut self) -> Result<()> {
        self.top_frame_mut().bytecode.write_simple(opcodes::RETURN)?;
        Ok(())
    }
}

impl Codegen for BytecodeCodegen {
    type Input = VuurModule;
    type Output = Chunk;

    fn compile(&mut self, module: &Self::Input) -> Result<Self::Output> {
        self.compile_module(module)?;

        Ok(self.take())
    }
}
