use vuur_parse::cond::{ElseStmt, IfStmt};
use vuur_parse::expr::{Expr, OperatorKind};
use vuur_parse::module::VuurModule;
use vuur_parse::stmt::{DefStmt, SimpleStmt};

use crate::bytecode::{decode_opcode, encode_u64, opcodes, WriteBytecode};
use crate::chunk::{Chunk, ChunkHeader};
use crate::constants::*;
use crate::error::{CompileError, ErrorKind, Result};
use crate::func::FuncId;
use crate::limits::*;
use crate::FuncDef;

// TODO: Replace String error with proper error type

/// Function compilation environment.
///
/// This contains the state required to compile a function.
struct FuncEnv {
    /// Function ID of this block in the chunk's function table.
    id: Option<FuncId>,
    /// Name of the callable.
    ///
    /// For functions this is the function name, for the
    /// top level anonymous module function this would be `None`.
    name: Option<String>,
    /// Unnamed scalar constant values.
    constants: ConstantTable,
    /// String constant values.
    strings: Vec<String>,
    /// Local variable values, including the function's parameters.
    locals: Vec<String>,
    /// Local functions.
    ///
    /// This indicates which functions belong to this scope. The `FuncId` is
    /// generated by the `Chunk`, where it's used as the index for the table lookup.
    ///
    /// TODO: Functions should be looked up by name, receiver type and argument signature.
    funcs: Vec<(String, FuncId)>,
    /// Buffer of bytecode that belongs to this function.
    bytecode: Vec<u32>,
    /// Start and end bytecode addresses.
    bytecode_span: (u32, u32),
}

impl FuncEnv {
    fn add_constant(&mut self, konst: ConstValue) -> usize {
        self.constants.add_constant(konst)
    }

    fn prev_addr(&self) -> u32 {
        let len = self.bytecode.len() as u32;
        if len == 0 {
            0
        } else {
            len - 1
        }
    }

    fn next_addr(&self) -> u32 {
        self.bytecode.len() as u32
    }
}

impl Default for FuncEnv {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            constants: ConstantTable::new(),
            strings: Vec::new(),
            locals: Vec::new(),
            funcs: Vec::new(),
            bytecode: Vec::new(),
            bytecode_span: (0, 0),
        }
    }
}

struct ConstantTable {
    values: Vec<ConstValue>,
    next_index: usize,
}

impl ConstantTable {
    fn new() -> Self {
        Self {
            values: vec![],
            next_index: 0,
        }
    }

    fn add_constant(&mut self, value: ConstValue) -> usize {
        match self.values.iter().position(|el| el == &value) {
            Some(index) => index,
            None => {
                let next_index = self.next_index;
                self.next_index += value.encoded_size();
                self.values.push(value);
                next_index
            }
        }
    }

    fn len(&self) -> usize {
        self.next_index
    }

    fn is_empty(&self) -> bool {
        self.next_index == 0
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
enum ConstValue {
    I32(i32),
    F32(f32),
    I64(i64),
    F64(f64),
    Bool(bool),
}

impl ConstValue {
    /// Size of constant value when encoded into u32.
    fn encoded_size(&self) -> usize {
        match self {
            Self::I32(_) | Self::F32(_) => 1,
            Self::I64(_) | Self::F64(_) => 2,
            Self::Bool(_) => 1,
        }
    }

    fn to_bits(&self) -> Option<u32> {
        match *self {
            Self::I32(val) => Some(val as u32),
            Self::F32(val) => Some(val.to_bits()),
            _ => None,
        }
    }

    fn to_bits2(&self) -> Option<[u32; 2]> {
        match *self {
            Self::I64(val) => Some(encode_u64(val as u64)),
            Self::F64(val) => Some(encode_u64(val.to_bits())),
            _ => None,
        }
    }
}

#[derive(Debug)]
enum SymbolScope<T> {
    Local(T),
    NonLocal(T),
    Global(T),
}

impl<T> SymbolScope<T> {
    fn is_local(&self) -> bool {
        matches!(self, Self::Local(_))
    }

    fn local(self) -> Option<T> {
        match self {
            Self::Local(inner) => Some(inner),
            _ => None,
        }
    }
}

/// Code generator that outputs interpreter bytecode.
pub struct BytecodeCodegen {
    /// Result buffer of generated bytecode
    chunk: Chunk,
    /// Stack of nested function environments.
    funcs: Vec<FuncEnv>,
    /// Mapping of bytecode to original source line.
    ///
    /// The index in the vector is equal to the bytecode's offset
    /// in the generated binary. The elements are line numbers in
    /// the source code text, starting at 1.
    ///
    /// Used to add source text information when disassembling.
    // TODO: Source mapping
    _lines: Vec<usize>,
}

impl BytecodeCodegen {
    pub fn new() -> Self {
        Self {
            chunk: Chunk::default(),
            funcs: Vec::with_capacity(64),
            _lines: Vec::new(),
        }
    }

    pub fn compile(&mut self, module: &VuurModule) -> Result<Chunk> {
        self.compile_module(module)?;

        Ok(self.take())
    }

    fn take(&mut self) -> Chunk {
        let mut chunk = Chunk::default();
        std::mem::swap(&mut chunk, &mut self.chunk);

        self.reset();

        chunk
    }

    /// Reset internal state of code generator to a clean slate,
    /// ready for another code generation run.
    fn reset(&mut self) {
        *self = BytecodeCodegen::new();
    }

    /// Retrieve the top environment on the top of the environment stack, mutably.
    ///
    /// If the stack is empty, a new environment is created and pushed onto the stack.
    fn top_env_mut(&mut self) -> &mut FuncEnv {
        // Create default function to make this infallible.
        if self.funcs.is_empty() {
            self.funcs.push(FuncEnv::default());
            &mut self.funcs[0]
        } else {
            self.funcs.last_mut().unwrap()
        }
    }

    /// Retrieve the top environment on the top of the environment stack.
    fn top_env(&self) -> Option<&FuncEnv> {
        self.funcs.last()
    }

    fn resolve_func(&self, name: &str) -> Result<SymbolScope<FuncId>> {
        for (index, block) in self.funcs.iter().enumerate() {
            let is_local = index == 0;
            let is_global = if self.funcs.len() != 0 {
                index == self.funcs.len() - 1
            } else {
                false
            };

            let maybe_func_id = block.funcs.iter().find(|(n, _)| n == name).map(|(_, id)| id).copied();

            if let Some(func_id) = maybe_func_id {
                return if is_local {
                    Ok(SymbolScope::Local(func_id))
                } else if is_global {
                    Ok(SymbolScope::Global(func_id))
                } else {
                    Err(CompileError {
                        message: format!("error resolving function '{name}': closures not implemented yet"),
                        kind: ErrorKind::Compiler,
                    })
                };
            }
        }

        Err(CompileError {
            message: format!("could not resolve function with name '{name}'"),
            kind: ErrorKind::Compiler,
        })
    }

    fn write_header(&mut self) {
        let header = ChunkHeader {
            version: CHUNK_VERSION,
            endianess: CHUNK_ENDIAN_LIT,
            size_t: CHUNK_SIZE_32,
        };
        self.chunk.header = header;
    }

    fn begin_func(&mut self) {
        self.funcs.push(FuncEnv {
            bytecode_span: (self.chunk.code.len() as u32, 0),
            ..FuncEnv::default()
        });
    }

    fn push_func(&mut self, func_id: FuncId) {
        self.funcs.push(FuncEnv {
            id: Some(func_id),
            bytecode_span: (self.chunk.code.len() as u32, 0),
            ..FuncEnv::default()
        });
    }

    /// Pops the top function state and emits it into the chunk bytecode.
    fn finish_func(&mut self) -> Result<FuncId> {
        match self.funcs.pop() {
            Some(func) => {
                // Emit function def header
                // self.chunk.code_mut().write_simple(opcodes::FUNC)?;

                // Write constants
                // self.chunk.code_mut().write_data(func.constants.len() as u32)?;
                // for konst in &func.constants.values {
                //     self.chunk.code_mut().write_data(konst.to_bits().unwrap_or_default())?;
                // }

                // Write bytecode instructions
                let span_start = self.chunk.code.len() as u32;
                self.chunk.code.extend_from_slice(&func.bytecode);
                let span_end = self.chunk.code.len() as u32;

                let func_id = func.id.expect("block must have function ID");

                self.chunk.replace_func_stub(FuncDef {
                    id: Some(func_id),
                    bytecode_span: (span_start, span_end),
                });

                Ok(func_id)
            }
            None => Err(CompileError::new(
                ErrorKind::Compiler,
                "failed to finalize function: no current function being compiled",
            )),
        }
    }

    fn compile_module(&mut self, module: &VuurModule) -> Result<()> {
        self.write_header();

        // Top level of a module is an anonymous function
        self.begin_func();
        self.top_env_mut().id = Some(self.chunk.add_func_stub());

        self.compile_body(&module.stmts)?;
        self.compile_return(None)?;

        self.finish_func()?;

        Ok(())
    }

    fn compile_body(&mut self, stmts: &[DefStmt]) -> Result<()> {
        self.compile_decls(stmts)?;
        self.compile_def_stmts(stmts)
    }

    /// Compile the prototypes of types and function declaration,
    /// but not their bodies.
    fn compile_decls(&mut self, stmts: &[DefStmt]) -> Result<()> {
        for stmt in stmts {
            match stmt {
                DefStmt::Type() => {
                    todo!("compile tpye declaration")
                }
                DefStmt::Func(func) => self.compile_func_prototype(func)?,
                _ => { /* skip */ }
            }
        }

        Ok(())
    }

    fn compile_def_stmts(&mut self, stmts: &[DefStmt]) -> Result<()> {
        for def_stmt in stmts {
            match def_stmt {
                DefStmt::Func(func) => {
                    self.compile_func_body(func)?;
                }
                DefStmt::Return => {
                    self.compile_return(None)?;
                }
                DefStmt::Return1(ret) => {
                    self.compile_return(Some(ret))?;
                }
                DefStmt::Simple(stmt) => {
                    // FIXME: Remove comment when `force_multiline_blocks` is stabilised: https://github.com/rust-lang/rustfmt/issues/3374
                    match stmt {
                        SimpleStmt::If(stmt) => self.compile_if_stmt(stmt)?,
                        SimpleStmt::Expr(expr) => self.compile_expr(expr)?,
                        _ => todo!("{stmt:?}"),
                    }
                }
                _ => todo!(),
            }
        }

        Ok(())
    }

    fn compile_func_prototype(&mut self, func: &vuur_parse::func::FuncDef) -> Result<()> {
        let name = func.name.text.as_str();

        // TODO: Receiver

        // Use name to declare symbol and check for uniqueness in namespace.
        self.top_env_mut().name = Some(name.to_owned());

        // TODO: Signature (parameters and return type)
        // TODO: Check name + sig uniqueness
        let _func_id = match self.resolve_func(name) {
            // When the symbol already exists in the current scope, then
            // a name conflict has occurred.
            Ok(symbol) if symbol.is_local() => {
                return Err(CompileError {
                    message: format!("local function with name '{}' already declared", name),
                    kind: ErrorKind::Compiler,
                });
            }
            // When the symbol exists in the global scope, we can shadow it.
            Ok(_) | Err(_) => {
                // Add a function stub to the chunk so we can reserve a function ID.
                let func_id = self.chunk.add_func_stub();

                // Add the function symbol to the current scope so it can be resolved later.
                self.top_env_mut().funcs.push((name.to_string(), func_id));
            }
        };

        // TODO: Declare function type using signature

        Ok(())
    }

    fn compile_func_body(&mut self, func: &vuur_parse::func::FuncDef) -> Result<()> {
        // Function declaration should have been added to the lookup table
        // in a previous pass.
        let symbol = self.resolve_func(func.name.text.as_str())?;
        assert!(
            symbol.is_local(),
            "function body can only be compiled in the scope where it was declared"
        );

        let func_id = symbol.local().unwrap();
        self.push_func(func_id);

        self.compile_body(&func.body.stmts)?;

        // Add function declaration to its parent's scope.
        let func_id = self.finish_func()?;
        self.top_env_mut().funcs.push((func.name.text.to_string(), func_id)); // parent

        Ok(())
    }

    fn compile_if_stmt(&mut self, stmt: &IfStmt) -> Result<()> {
        self.compile_expr(&stmt.cond)?;

        // If conditional
        let stub_addr = {
            let env = self.top_env_mut();

            // OPTI: Check the comparison instruction of the conditional
            //       expression that was just compiled, and merge it into
            //       a single cmp+skip instruction.
            match env.bytecode.last().copied().map(decode_opcode) {
                Some(opcodes::EQ_I32) => {
                    env.bytecode.patch_simple(env.prev_addr(), opcodes::SKIP_EQ_I32)?;
                }
                Some(_) | None => {
                    // Skip next instruction if boolean expression evaluates to true.
                    env.bytecode.write_simple(opcodes::SKIP_1)?;
                }
            }

            // Stub to jump to false case.
            env.bytecode.write_simple(opcodes::NOOP)?
        };

        // True block body
        self.compile_def_stmts(&stmt.body.stmts)?;

        {
            // Target jump when conditional is false.
            let env = self.top_env_mut();
            let after_addr = env.next_addr();
            env.bytecode
                .patch_k(stub_addr, opcodes::JUMP, env.bytecode_span.0 + after_addr)?;
        }

        match &stmt.else_ {
            ElseStmt::Empty => { /* do nothing */ }
            ElseStmt::Else { body } => self.compile_def_stmts(&body.stmts)?,
            ElseStmt::ElseIf(else_stmt) => self.compile_if_stmt(else_stmt)?,
        }

        Ok(())
    }

    fn compile_expr(&mut self, expr: &Expr) -> Result<()> {
        match expr {
            // Number literal becomes a constant with no name.
            Expr::Num(num) => {
                let env = self.top_env_mut();
                let lit = num.value;

                // If the literal is small enough, inline it into an immediate instruction.
                if lit >= 0 && lit <= INSTRUCTION_A_MAX {
                    env.bytecode.write_a(opcodes::PUSH_CONST_IMM, lit)?;
                } else {
                    // Integer is too large to be inlined into the bytecode.
                    // Add it to the constant table.
                    // TODO: Floats
                    let index = env.add_constant(ConstValue::I32(lit));

                    if index > MAX_CONSTANTS {
                        return Err(CompileError::new(
                            ErrorKind::Compiler,
                            "maximum function constants exceeded",
                        ));
                    }

                    // Emit
                    env.bytecode.write_k(opcodes::PUSH_CONST, index as u32)?;
                }
            }
            Expr::Unary(unary) => {
                self.compile_expr(&unary.rhs)?;

                let scope = self.top_env_mut();

                match unary.operator.kind {
                    OperatorKind::Neg => {
                        scope.bytecode.write_simple(opcodes::NEG_I32)?;
                    }
                    _ => todo!("unary operator kind {:?}", unary.operator.kind),
                }
            }
            Expr::Binary(binary) => {
                self.compile_expr(&binary.lhs)?;
                self.compile_expr(&binary.rhs)?;

                let scope = self.top_env_mut();

                match binary.operator.kind {
                    OperatorKind::Add => scope.bytecode.write_simple(opcodes::ADD_I32)?,
                    OperatorKind::Sub => scope.bytecode.write_simple(opcodes::SUB_I32)?,
                    OperatorKind::Mul => scope.bytecode.write_simple(opcodes::MUL_I32)?,
                    OperatorKind::Div => scope.bytecode.write_simple(opcodes::DIV_I32)?,
                    OperatorKind::Equals => scope.bytecode.write_simple(opcodes::EQ_I32)?,
                    _ => todo!("binary operator kind {:?}", binary.operator.kind),
                };
            }
            Expr::Group(group) => {
                self.compile_expr(&group.expr)?;
            }
            Expr::NameAccess(_) => {
                eprintln!("name access not implemented");
                self.top_env_mut().bytecode.write_simple(opcodes::PUSH_LOCAL_I32)?;
            }
            Expr::Call(call) => {
                // TODO: Lookup function by name
                match &*call.callee {
                    // When the function name is explicitly stated as a string literal,
                    // then the call can simply be statically dispatched.
                    Expr::NameAccess(access) => {
                        let name = &access.ident.text;
                        match self.resolve_func(name.as_str())? {
                            SymbolScope::Local(func_id) | SymbolScope::Global(func_id) => {
                                self.top_env_mut().bytecode.write_k(opcodes::CALL, func_id.to_u32())?;
                            }
                            SymbolScope::NonLocal(_) => todo!("closures"),
                        }
                    }
                    // When the function is namespaced to a struct, the member path needs to be resolved.
                    Expr::MemberAccess(access) => {
                        todo!("struct member call: '{access:?}'")
                    }
                    // When a more complex expression is used as the function name, then
                    // it has to be evaluated at runtime and dispatched dynamically.
                    expr => {
                        self.compile_expr(expr)?;
                        self.top_env_mut().bytecode.write_simple(opcodes::DYN_CALL)?;
                    }
                }
            }
            _ => todo!("{expr:?}"),
        }

        Ok(())
    }

    fn compile_return(&mut self, expr: Option<&Expr>) -> Result<()> {
        match expr {
            Some(expr) => {
                // TODO: Support multiple return values
                self.compile_expr(expr)?;
                self.top_env_mut().bytecode.write_k(opcodes::RETURN, 1)?;
            }
            None => {
                self.top_env_mut().bytecode.write_k(opcodes::RETURN, 0)?;
            }
        }

        Ok(())
    }
}
