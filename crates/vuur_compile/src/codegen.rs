use vuur_parse::cond::{ElseStmt, IfStmt};
use vuur_parse::expr::{Expr, OperatorKind};
use vuur_parse::module::VuurModule;
use vuur_parse::stmt::{DefStmt, SimpleStmt};

use crate::bytecode::{encode_u64, opcodes, WriteBytecode};
use crate::chunk::{Chunk, ChunkHeader};
use crate::constants::*;
use crate::error::{CompileError, ErrorKind, Result};
use crate::limits::*;
use crate::FuncDef;

// TODO: Replace String error with proper error type

/// Function compilation environment.
///
/// This contains the state required to compile a function.
struct FuncEnv {
    /// Name of the callable.
    ///
    /// For functions this is the function name, for the
    /// top level anonymous module function this would be `None`.
    name: Option<String>,
    /// Unnamed scalar constant values.
    constants: ConstantTable,
    /// String constant values.
    strings: Vec<String>,
    /// Local variable values, including the function's parameters.
    locals: Vec<String>,
    /// Buffer of bytecode that belongs to this function.
    bytecode: Vec<u32>,
    /// Start and end bytecode addresses.
    bytecode_span: (u32, u32),
}

impl FuncEnv {
    fn add_constant(&mut self, konst: ConstValue) -> usize {
        self.constants.add_constant(konst)
    }

    fn next_addr(&self) -> u32 {
        self.bytecode.len() as u32
    }
}

impl Default for FuncEnv {
    fn default() -> Self {
        Self {
            name: None,
            constants: ConstantTable::new(),
            strings: Vec::new(),
            locals: Vec::new(),
            bytecode: Vec::new(),
            bytecode_span: (0, 0),
        }
    }
}

struct ConstantTable {
    values: Vec<ConstValue>,
    next_index: usize,
}

impl ConstantTable {
    fn new() -> Self {
        Self {
            values: vec![],
            next_index: 0,
        }
    }

    fn add_constant(&mut self, value: ConstValue) -> usize {
        match self.values.iter().position(|el| el == &value) {
            Some(index) => index,
            None => {
                let next_index = self.next_index;
                self.next_index += value.encoded_size();
                self.values.push(value);
                next_index
            }
        }
    }

    fn len(&self) -> usize {
        self.next_index
    }

    fn is_empty(&self) -> bool {
        self.next_index == 0
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
enum ConstValue {
    I32(i32),
    F32(f32),
    I64(i64),
    F64(f64),
    Bool(bool),
}

impl ConstValue {
    /// Size of constant value when encoded into u32.
    fn encoded_size(&self) -> usize {
        match self {
            Self::I32(_) | Self::F32(_) => 1,
            Self::I64(_) | Self::F64(_) => 2,
            Self::Bool(_) => 1,
        }
    }

    fn to_bits(&self) -> Option<u32> {
        match *self {
            Self::I32(val) => Some(val as u32),
            Self::F32(val) => Some(val.to_bits()),
            _ => None,
        }
    }

    fn to_bits2(&self) -> Option<[u32; 2]> {
        match *self {
            Self::I64(val) => Some(encode_u64(val as u64)),
            Self::F64(val) => Some(encode_u64(val.to_bits())),
            _ => None,
        }
    }
}

/// Code generator that outputs interpreter bytecode.
pub struct BytecodeCodegen {
    /// Result buffer of generated bytecode
    chunk: Chunk,
    /// Stack of nested function environments.
    funcs: Vec<FuncEnv>,
    /// Mapping of bytecode to original source line.
    ///
    /// The index in the vector is equal to the bytecode's offset
    /// in the generated binary. The elements are line numbers in
    /// the source code text, starting at 1.
    ///
    /// Used to add source text information when disassembling.
    // TODO: Source mapping
    _lines: Vec<usize>,
}

impl BytecodeCodegen {
    pub fn new() -> Self {
        Self {
            chunk: Chunk::default(),
            funcs: Vec::with_capacity(64),
            _lines: Vec::new(),
        }
    }

    pub fn compile(&mut self, module: &VuurModule) -> Result<Chunk> {
        self.compile_module(module)?;

        Ok(self.take())
    }

    fn take(&mut self) -> Chunk {
        let mut chunk = Chunk::default();
        std::mem::swap(&mut chunk, &mut self.chunk);

        self.reset();

        chunk
    }

    /// Reset internal state of code generator to a clean slate,
    /// ready for another code generation run.
    fn reset(&mut self) {
        *self = BytecodeCodegen::new();
    }

    /// Retrieve the top environment on the top of the environment stack, mutably.
    ///
    /// If the stack is empty, a new environment is created and pushed onto the stack.
    fn top_env_mut(&mut self) -> &mut FuncEnv {
        // Create default function to make this infallible.
        if self.funcs.is_empty() {
            self.funcs.push(FuncEnv::default());
            &mut self.funcs[0]
        } else {
            self.funcs.last_mut().unwrap()
        }
    }

    /// Retrieve the top environment on the top of the environment stack.
    fn top_env(&self) -> Option<&FuncEnv> {
        self.funcs.last()
    }

    fn write_header(&mut self) {
        let header = ChunkHeader {
            version: CHUNK_VERSION,
            endianess: CHUNK_ENDIAN_LIT,
            size_t: CHUNK_SIZE_32,
        };
        self.chunk.header = header;
    }

    fn begin_func(&mut self) {
        self.funcs.push(FuncEnv {
            bytecode_span: (self.chunk.code.len() as u32, 0),
            ..FuncEnv::default()
        })
    }

    /// Pops the top function state and emits it into the chunk bytecode.
    fn finish_func(&mut self) -> Result<()> {
        match self.funcs.pop() {
            Some(func) => {
                // Emit function def header
                self.chunk.code_mut().write_simple(opcodes::FUNC)?;

                // Write constants
                self.chunk.code_mut().write_data(func.constants.len() as u32)?;
                for konst in &func.constants.values {
                    self.chunk.code_mut().write_data(konst.to_bits().unwrap_or_default())?;
                }

                // Write bytecode instructions
                let span_start = self.chunk.code.len() as u32;
                self.chunk.code.extend_from_slice(&func.bytecode);
                let span_end = self.chunk.code.len() as u32;

                let func_id = self.chunk.add_func(FuncDef {
                    id: None,
                    bytecode_span: (span_start, span_end),
                });

                Ok(())
            }
            None => Err(CompileError::new(
                ErrorKind::Compiler,
                "failed to finalize function: no current function being compiled",
            )),
        }
    }

    fn compile_module(&mut self, module: &VuurModule) -> Result<()> {
        self.write_header();

        // Top level of a module is an anonymous function
        self.begin_func();

        self.compile_def_stmts(&module.stmts)?;
        self.compile_return(None)?;

        self.finish_func()?;

        Ok(())
    }

    fn compile_def_stmts(&mut self, stmts: &[DefStmt]) -> Result<()> {
        for def_stmt in stmts {
            match def_stmt {
                DefStmt::Func(func) => {
                    self.compile_func_def(func)?;
                }
                DefStmt::Return(ret) => {
                    self.compile_return(Some(ret))?;
                }
                DefStmt::Simple(stmt) => {
                    // FIXME: Remove comment when `force_multiline_blocks` is stabilised: https://github.com/rust-lang/rustfmt/issues/3374
                    match stmt {
                        SimpleStmt::If(stmt) => self.compile_if_stmt(stmt)?,
                        SimpleStmt::Expr(expr) => self.compile_expr(expr)?,
                        _ => todo!("{stmt:?}"),
                    }
                }
                _ => todo!(),
            }
        }

        Ok(())
    }

    fn compile_func_def(&mut self, func: &vuur_parse::func::FuncDef) -> Result<()> {
        self.begin_func();

        // TODO: Receiver

        // Use name to declare symbol and check for uniqueness in namespace.
        let mut env = self.top_env_mut();
        env.name = Some(func.name.text.to_string());

        // TODO: Signature (parameters and return type)
        // TODO: Check name + sig uniqueness
        // TODO: Declare function type using signature

        self.compile_def_stmts(&func.body.stmts)?;

        self.finish_func()?;
        Ok(())
    }

    fn compile_if_stmt(&mut self, stmt: &IfStmt) -> Result<()> {
        self.compile_expr(&stmt.cond)?;

        // If conditional
        let stub_addr = {
            let env = self.top_env_mut();

            // Skip next instruction if boolean expression evaluates to true.
            env.bytecode.write_simple(opcodes::SKIP_ONE)?;

            // Stub to jump to false case.
            env.bytecode.write_simple(opcodes::NOOP)?
        };

        // True block body
        self.compile_def_stmts(&stmt.body.stmts)?;

        {
            // Target jump when conditional is false.
            let env = self.top_env_mut();
            let after_addr = env.next_addr();
            env.bytecode
                .patch_k(stub_addr, opcodes::JUMP, env.bytecode_span.0 + after_addr)?;
        }

        match &stmt.else_ {
            ElseStmt::Empty => { /* do nothing */ }
            ElseStmt::Else { body } => self.compile_def_stmts(&body.stmts)?,
            ElseStmt::ElseIf(else_stmt) => self.compile_if_stmt(else_stmt)?,
        }

        Ok(())
    }

    fn compile_expr(&mut self, expr: &Expr) -> Result<()> {
        match expr {
            // Number literal becomes a constant with no name.
            Expr::Num(num) => {
                let env = self.top_env_mut();
                let lit = num.value;

                // If the literal is small enough, inline it into an immediate instruction.
                if lit >= 0 && lit <= INSTRUCTION_A_MAX {
                    env.bytecode.write_a(opcodes::PUSH_CONST_IMM, lit)?;
                } else {
                    // Integer is too large to be inlined into the bytecode.
                    // Add it to the constant table.
                    // TODO: Floats
                    let index = env.add_constant(ConstValue::I32(lit));

                    if index > MAX_CONSTANTS {
                        return Err(CompileError::new(
                            ErrorKind::Compiler,
                            "maximum function constants exceeded",
                        ));
                    }

                    // Emit
                    env.bytecode.write_k(opcodes::PUSH_CONST, index as u32)?;
                }
            }
            Expr::Unary(unary) => {
                self.compile_expr(&unary.rhs)?;

                let scope = self.top_env_mut();

                match unary.operator.kind {
                    OperatorKind::Neg => {
                        scope.bytecode.write_simple(opcodes::NEG_I32)?;
                    }
                    _ => todo!("unary operator kind {:?}", unary.operator.kind),
                }
            }
            Expr::Binary(binary) => {
                self.compile_expr(&binary.lhs)?;
                self.compile_expr(&binary.rhs)?;

                let scope = self.top_env_mut();

                match binary.operator.kind {
                    OperatorKind::Add => scope.bytecode.write_simple(opcodes::ADD_I32)?,
                    OperatorKind::Sub => scope.bytecode.write_simple(opcodes::SUB_I32)?,
                    OperatorKind::Mul => scope.bytecode.write_simple(opcodes::MUL_I32)?,
                    OperatorKind::Div => scope.bytecode.write_simple(opcodes::DIV_I32)?,
                    OperatorKind::Equals => scope.bytecode.write_simple(opcodes::EQ_I32)?,
                    _ => todo!("binary operator kind {:?}", binary.operator.kind),
                };
            }
            Expr::Group(group) => {
                self.compile_expr(&group.expr)?;
            }
            Expr::NameAccess(_) => {
                eprintln!("name access not implemented");
                self.top_env_mut().bytecode.write_simple(opcodes::PUSH_LOCAL_I32)?;
            }
            Expr::Call(call) => {
                // TODO: Lookup function by name
                match &*call.callee {
                    // When the function name is explicitly stated as a string literal,
                    // then the call can simply be statically dispatched.
                    Expr::NameAccess(access) => {
                        let name = &access.ident.text;
                        println!("todo: function symbol lookup '{name}'");
                        // TODO: Function id
                        self.top_env_mut().bytecode.write_k(opcodes::CALL, 0)?;
                    }
                    // When the function is namespaced to a struct, the member path needs to be resolved.
                    Expr::MemberAccess(access) => {
                        todo!("struct member call: '{access:?}'")
                    }
                    // When a more complex expression is used as the function name, then
                    // it has to be evaluated at runtime and dispatched dynamically.
                    expr => {
                        self.compile_expr(expr)?;
                        self.top_env_mut().bytecode.write_simple(opcodes::DYN_CALL)?;
                    }
                }
            }
            _ => todo!("{expr:?}"),
        }

        Ok(())
    }

    fn compile_return(&mut self, expr: Option<&Expr>) -> Result<()> {
        if let Some(expr) = expr {
            self.compile_expr(expr)?;
        }
        self.top_env_mut().bytecode.write_simple(opcodes::RETURN)?;
        Ok(())
    }
}
